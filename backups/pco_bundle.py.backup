#!/usr/bin/env python3
# +-------------------------------------------------------------+

# |                          CERTEUS                            |

# +-------------------------------------------------------------+

# | FILE: services/api_gateway/routers/pco_bundle.py          |

# | ROLE: Project module.                                       |

# | PLIK: services/api_gateway/routers/pco_bundle.py          |

# | ROLA: Moduł projektu.                                       |

# +-------------------------------------------------------------+

"""
PL: Router FastAPI dla obszaru pakiety PCO.

EN: FastAPI router for PCO bundles.
"""

# === IMPORTY / IMPORTS ===

from __future__ import annotations

import base64
import hashlib
import json
import os
import re
import time
from pathlib import Path
from typing import Any

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import Response
from jsonschema import Draft202012Validator
from pydantic import BaseModel, Field, field_validator

from core.pco.crypto import (canonical_bundle_hash_hex, canonical_digest_hex,
                             compute_leaf_hex)
from monitoring.metrics_slo import (certeus_compile_duration_ms,
                                    certeus_proof_verification_failed_total)
from services.api_gateway.limits import enforce_limits
from services.proof_verifier import verify_drat, verify_lfsc
from services.proofgate.app import PublishRequest, PublishResponse, publish

# === KONFIGURACJA / CONFIGURATION ===

# === MODELE / MODELS ===


class MerkleStep(BaseModel):
    sibling: str

    dir: str  # "L" | "R"


class PublicBundleIn(BaseModel):
    rid: str = Field(..., min_length=1)

    smt2_hash: str = Field(..., min_length=64, max_length=64)

    lfsc: str = Field(..., min_length=2)

    drat: str | None = None

    merkle_proof: list[MerkleStep] | dict | None = Field(default=None)

    smt2: str | None = None

    @field_validator("smt2_hash")
    @classmethod
    def _hx64(cls, v: str) -> str:
        if not isinstance(v, str):
            raise ValueError(f"smt2_hash must be a string, got {type(v)}")
        int(v, 16)
        return v.lower()


# === LOGIKA / LOGIC ===


def _sanitize_rid(rid: str) -> str:
    """Sanitize resource ID for safe file path usage."""
    if not rid or not isinstance(rid, str):
        return ""

    # Remove any characters that could be dangerous in file paths
    sanitized = re.sub(r'[^a-zA-Z0-9_\-.]', '', rid.strip())

    # Prevent directory traversal
    if '..' in sanitized or sanitized.startswith('.'):
        return ""

    # Limit length
    if len(sanitized) > 64:
        sanitized = sanitized[:64]

    return sanitized


router = APIRouter(prefix="/v1/pco", tags=["pco"])


def _bundle_dir() -> Path:
    return Path(os.getenv("PROOF_BUNDLE_DIR") or "./data/public_pco")


def _parse_merkle_proof(raw: object) -> list[MerkleStep]:
    if raw is None:
        return []

    if isinstance(raw, dict) and "path" in raw:
        raw = raw["path"]

    if isinstance(raw, list):
        norm: list[MerkleStep] = []

        for step in raw:
            if isinstance(step, MerkleStep):
                norm.append(step)

                continue

            if not isinstance(step, dict):
                raise HTTPException(status_code=400, detail="Invalid merkle step type")

            d = step.get("dir") or step.get("position")

            sib = step.get("sibling")

            if d not in ("L", "R"):
                raise HTTPException(status_code=400, detail="Invalid merkle step.dir/position")

            if not isinstance(sib, str) or not sib:
                raise HTTPException(status_code=400, detail="Invalid merkle step: missing 'sibling'")

            norm.append(MerkleStep(sibling=sib, dir=str(d)))

        return norm

    raise HTTPException(status_code=400, detail="merkle_proof must be list or {path:[...] }")


def _apply_merkle_path(leaf_hex: str, path: list[MerkleStep]) -> str:
    if not path:
        return leaf_hex.lower()

    cur = bytes.fromhex(leaf_hex)

    for step in path:
        sib = bytes.fromhex(step.sibling)

        if step.dir == "L":
            cur = hashlib.sha256(sib + cur).digest()

        elif step.dir == "R":
            cur = hashlib.sha256(cur + sib).digest()

        else:
            raise HTTPException(status_code=400, detail=f"Invalid merkle step.dir: {step.dir}")

    return cur.hex()


def _load_private_key_from_pem() -> Ed25519PrivateKey:
    pem_env = os.getenv("ED25519_PRIVKEY_PEM")

    if pem_env and "BEGIN" in pem_env:
        key_any = serialization.load_pem_private_key(pem_env.encode("utf-8"), password=None)

        if not isinstance(key_any, Ed25519PrivateKey):
            raise HTTPException(status_code=500, detail="PEM from env is not Ed25519 private key")

        return key_any

    pem_path = os.getenv("ED25519_PRIVKEY_PEM_PATH") or os.getenv("ED25519_PRIVKEY_PEM")

    if pem_path and Path(pem_path).exists():
        key_any = serialization.load_pem_private_key(Path(pem_path).read_bytes(), password=None)

        if not isinstance(key_any, Ed25519PrivateKey):
            raise HTTPException(status_code=500, detail="PEM file is not an Ed25519 private key")

        return key_any

    # Developer-friendly fallback: use local .devkeys/ed25519_priv.pem if present
    try:
        dev_pem = Path(".devkeys") / "ed25519_priv.pem"
        if dev_pem.exists():
            key_any = serialization.load_pem_private_key(dev_pem.read_bytes(), password=None)
            if isinstance(key_any, Ed25519PrivateKey):
                return key_any
    except Exception:
        pass

    raise HTTPException(status_code=500, detail="Missing ED25519_PRIVKEY_PEM or *_PATH")


def _pb_schema_path() -> Path:
    # routers/ -> api_gateway/ -> schemas/

    return Path(__file__).resolve().parents[1] / "schemas" / "proofbundle_v0.2.json"


def _load_pb_schema() -> dict[str, Any]:
    p = _pb_schema_path()

    try:
        return json.loads(p.read_text(encoding="utf-8"))

    except Exception as e:  # pragma: no cover
        raise HTTPException(status_code=500, detail=f"Cannot load ProofBundle schema: {e}") from e


def _kid_from_pubkey(sk: Ed25519PrivateKey) -> str:
    pk = sk.public_key().public_bytes(encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw)

    return hashlib.sha256(pk).hexdigest()[:16]


def _now_iso() -> str:
    return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())


def _build_proofbundle(
    payload: PublicBundleIn,
    merkle_root_hex: str,
    digest_hex: str,
    signature_b64u: str,
    sk: Ed25519PrivateKey,
    *,
    status: str = "PENDING",
) -> dict[str, Any]:
    # Minimal, ale zgodny ze schematem ProofBundle v0.2 (z polami domyślnymi)

    # Zachowujemy spójność z istniejącym public payloadem: będziemy zapisywać oba zestawy pól.

    jurisdiction_country = os.getenv("DEFAULT_JURIS_COUNTRY", "PL")

    jurisdiction_domain = os.getenv("DEFAULT_JURIS_DOMAIN", "other")

    image = os.getenv("CERTEUS_IMAGE", "certeus/local:dev")

    image_digest = os.getenv("CERTEUS_IMAGE_DIGEST", "sha256:placeholder")

    seed = os.getenv("CERTEUS_SEED", "0")

    # sources: pseudo-URI oparty o hash SMT2

    src = {
        "id": "smt2",
        "uri": f"hash://sha256/{payload.smt2_hash}",
        "digest": payload.smt2_hash,
        "retrieved_at": _now_iso(),
        "license": "unknown",
    }

    # derivations: LFSC (+ opcjonalnie DRAT)

    derivs: list[dict[str, Any]] = [
        {
            "claim_id": "claim-1",
            "solver": "z3",
            "proof_format": "LFSC",
            "artifact_digest": hashlib.sha256(payload.lfsc.encode("utf-8")).hexdigest(),
        }
    ]

    if payload.drat is not None:
        derivs.append(
            {
                "claim_id": "claim-1",
                "solver": "z3",
                "proof_format": "DRAT",
                "artifact_digest": hashlib.sha256(payload.drat.encode("utf-8")).hexdigest(),
            }
        )

    pb: dict[str, Any] = {
        "version": "0.2",
        "case_id": payload.rid,
        "created_at": _now_iso(),
        "jurisdiction": {
            "country": jurisdiction_country,
            "domain": jurisdiction_domain,
        },
        "claims": [
            {
                "id": "claim-1",
                "text": f"Auto-generated claim for rid={payload.rid}",
                "legal_basis": {"statutes": [], "cases": []},
                "evidence_refs": [],
            }
        ],
        "sources": [src],
        "derivations": derivs,
        "risk": {"ece": 0.0, "brier": 0.0, "p95_latency_ms": 0, "abstain_rate": 0.0},
        "ledger": {"merkle_root": merkle_root_hex},
        "signatures": [
            {
                "role": "producer",
                "alg": "ed25519",
                "key_id": _kid_from_pubkey(sk),
                "signature": signature_b64u,
            }
        ],
        "reproducibility": {
            "image": image,
            "image_digest": image_digest,
            "seed": seed,
            "env": {},
        },
        "attachments": [],
        "status": status,
    }

    # Walidacja ze schematem

    schema = _load_pb_schema()

    Draft202012Validator(schema).validate(pb)

    return pb


# === I/O / ENDPOINTS ===

# PCO v1.0 Endpoints


class PCOBundleRequestV1(BaseModel):
    """Request model for PCO Bundle v1.0."""

    rid: str = Field(..., pattern=r'^[A-Z]{3}-[0-9]{6}$', description="Case ID (format: ABC-123456)")
    smt2_hash: str = Field(..., pattern=r'^[a-f0-9]{64}$', description="SHA256 hash of SMT2 formula")
    lfsc: str = Field(..., min_length=1, description="LFSC proof")
    drat: str | None = Field(None, description="Optional DRAT proof")
    smt2: str | None = Field(None, description="Full SMT2 formula (optional)")
    merkle_proof: list[MerkleStep] | None = Field(None, description="Merkle proof for verification")
    jurisdiction: dict | None = Field(None, description="Jurisdiction information")
    extensions: dict | None = Field(None, description="Extensions (QTMP, CFE, etc.)")


@router.post(
    "/bundle",
    summary="Create PCO Bundle v1.0",
    description="Creates, validates, signs and publishes a PCO Bundle v1.0 with full schema compliance",
)
def create_pco_bundle_v1(payload: PCOBundleRequestV1, request: Request) -> dict[str, Any]:
    """
    PL: Tworzy, waliduje, podpisuje i publikuje ProofBundle v1.0.
    EN: Creates, validates, signs and publishes ProofBundle v1.0.
    """

    # Konwertuj na format legacy dla kompatybilności
    legacy_payload = PublicBundleIn(
        rid=payload.rid,
        smt2_hash=payload.smt2_hash,
        lfsc=payload.lfsc,
        drat=payload.drat,
        merkle_proof=payload.merkle_proof,
        smt2=payload.smt2,
    )

    # Użyj istniejącej logiki, ale z pełną strukturą ProofBundle
    try:
        # Pobierz klucz i oblicz hashe
        sk = _get_signing_key()
        merkle_steps = _parse_merkle_proof(legacy_payload.merkle_proof)

        # Oblicz bundle hash używając canonical function
        bundle_hash_hex = canonical_bundle_hash_hex(legacy_payload.smt2_hash, legacy_payload.lfsc, legacy_payload.drat)

        # Oblicz leaf hash dla merkle tree
        leaf_hex = compute_leaf_hex(legacy_payload.rid, bundle_hash_hex)

        # Zastosuj merkle proof jeśli istnieje
        merkle_root_hex = _apply_merkle_path(leaf_hex, merkle_steps)

        # Podpisz z wykorzystaniem nowej funkcji canonical_digest_hex
        digest_hex = canonical_digest_hex(
            rid=legacy_payload.rid,
            smt2_hash_hex=legacy_payload.smt2_hash,
            lfsc_text=legacy_payload.lfsc,
            merkle_root_hex=merkle_root_hex,
            drat_text=legacy_payload.drat,
        )
        signature_b64u = _sign_digest(sk, digest_hex)

        # Zbuduj pełny ProofBundle
        pb_status = "PENDING"

        # Optional verification of SMT2 if provided; record SLO metrics
        if getattr(legacy_payload, "smt2", None):
            t0 = time.perf_counter()

            try:
                from kernel.truth_engine import \
                    DualCoreVerifier  # type: ignore

                _ = DualCoreVerifier().verify(legacy_payload.smt2 or "", lang="smt2", case_id=legacy_payload.rid)

            except Exception:
                certeus_proof_verification_failed_total.inc()

                pb_status = "ABSTAIN"

            finally:
                try:
                    certeus_compile_duration_ms.observe((time.perf_counter() - t0) * 1000.0)

                except Exception:
                    pass

        # Proof verification for LFSC/DRAT (light heuristic). Any failure -> ABSTAIN
        try:
            vr_lfsc = verify_lfsc(legacy_payload.lfsc)

            if not vr_lfsc.ok:
                certeus_proof_verification_failed_total.inc()

                pb_status = "ABSTAIN"

        except Exception:
            certeus_proof_verification_failed_total.inc()

            pb_status = "ABSTAIN"

        if legacy_payload.drat is not None:
            try:
                vr_drat = verify_drat(legacy_payload.drat)

                if not vr_drat.ok:
                    certeus_proof_verification_failed_total.inc()

                    pb_status = "ABSTAIN"

            except Exception:
                certeus_proof_verification_failed_total.inc()

                pb_status = "ABSTAIN"

        proofbundle = _build_proofbundle(
            legacy_payload, merkle_root_hex, digest_hex, signature_b64u, sk, status=pb_status
        )

        # Dodaj pola v1.0 i backward compatibility
        result = {
            **proofbundle,  # Pełna struktura PCO v1.0
            # Backward compatibility fields
            "ok": True,
            "rid": payload.rid,
            "smt2_hash": payload.smt2_hash,
            "lfsc": payload.lfsc,
            "drat": payload.drat,
            "signature": signature_b64u,
            "digest_hex": digest_hex,
            "public_path": str(_bundle_dir() / f"{_sanitize_rid(payload.rid)}.json"),
        }

        # Override z danymi z requestu
        if payload.jurisdiction:
            result["jurisdiction"].update(payload.jurisdiction)
        if payload.extensions:
            result["extensions"] = payload.extensions

        # Zapisz do pliku
        safe_rid = _sanitize_rid(payload.rid)
        if safe_rid:
            out_dir = _bundle_dir()
            out_dir.mkdir(exist_ok=True, parents=True)
            out_path = out_dir / f"{safe_rid}.json"
            out_path.write_text(json.dumps(result, ensure_ascii=False, indent=2), encoding="utf-8")
            result["public_path"] = str(out_path)

        return result

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create PCO Bundle: {str(e)}")


def _get_signing_key() -> Ed25519PrivateKey:
    """Pobiera klucz podpisywania z zmiennej środowiskowej."""
    pem_str = os.getenv("ED25519_PRIVKEY_PEM")
    pem_path = os.getenv("ED25519_PRIVKEY_PATH")

    if pem_str:
        try:
            if pem_str.startswith("-----"):
                return serialization.load_pem_private_key(pem_str.encode(), password=None)
            else:
                key_bytes = bytes.fromhex(pem_str)
                return Ed25519PrivateKey.from_private_bytes(key_bytes)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Invalid ED25519_PRIVKEY_PEM: {e}")

    if pem_path:
        try:
            with open(pem_path, 'rb') as f:
                return serialization.load_pem_private_key(f.read(), password=None)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Cannot load key from {pem_path}: {e}")

    raise HTTPException(status_code=500, detail="Missing ED25519_PRIVKEY_PEM or *_PATH")


def _sign_digest(sk: Ed25519PrivateKey, digest_hex: str) -> str:
    """Podpisuje digest i zwraca w formacie base64url."""
    try:
        digest_bytes = bytes.fromhex(digest_hex)
        signature_bytes = sk.sign(digest_bytes)
        return base64.urlsafe_b64encode(signature_bytes).decode('ascii').rstrip('=')
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Signing failed: {e}")


@router.post("/v1/bundle", deprecated=True, include_in_schema=False)
def create_bundle_legacy(payload: PublicBundleIn, request: Request) -> dict[str, Any]:
    """Legacy endpoint - redirects to new v1.0 endpoint."""
    return create_bundle(payload, request)


@router.post("/bundle_legacy")
def create_bundle(payload: PublicBundleIn, request: Request) -> dict[str, Any]:
    enforce_limits(request, cost_units=3)

    path = _parse_merkle_proof(payload.merkle_proof)

    bundle_hash_hex = canonical_bundle_hash_hex(payload.smt2_hash, payload.lfsc, payload.drat)

    leaf_hex = compute_leaf_hex(payload.rid, bundle_hash_hex)

    merkle_root_hex = _apply_merkle_path(leaf_hex, path)

    digest_hex = canonical_digest_hex(
        rid=payload.rid,
        smt2_hash_hex=payload.smt2_hash,
        lfsc_text=payload.lfsc,
        drat_text=payload.drat,
        merkle_root_hex=merkle_root_hex,
    )

    sk = _load_private_key_from_pem()

    signature_b64u = base64.urlsafe_b64encode(sk.sign(bytes.fromhex(digest_hex))).rstrip(b"=").decode("ascii")

    out_obj: dict[str, Any] = {
        "rid": payload.rid,
        "smt2_hash": payload.smt2_hash,
        "lfsc": payload.lfsc,
        "merkle_proof": [step.model_dump() for step in path],
        "signature": signature_b64u,
        "issued_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    }

    if payload.drat is not None:
        out_obj["drat"] = payload.drat

    # Optional verification of SMT2 if provided; record SLO metrics

    pb_status = "PENDING"

    if getattr(payload, "smt2", None):
        t0 = time.perf_counter()

        try:
            from kernel.truth_engine import DualCoreVerifier  # type: ignore

            _ = DualCoreVerifier().verify(payload.smt2 or "", lang="smt2", case_id=payload.rid)

        except Exception:
            certeus_proof_verification_failed_total.inc()

            pb_status = "ABSTAIN"

        finally:
            try:
                certeus_compile_duration_ms.observe((time.perf_counter() - t0) * 1000.0)

            except Exception:
                pass

    # Proof verification for LFSC/DRAT (light heuristic). Any failure -> ABSTAIN

    try:
        vr_lfsc = verify_lfsc(payload.lfsc)

        if not vr_lfsc.ok:
            certeus_proof_verification_failed_total.inc()

            pb_status = "ABSTAIN"

    except Exception:
        certeus_proof_verification_failed_total.inc()

        pb_status = "ABSTAIN"

    if payload.drat is not None:
        try:
            vr_drat = verify_drat(payload.drat)

            if not vr_drat.ok:
                certeus_proof_verification_failed_total.inc()

                pb_status = "ABSTAIN"

        except Exception:
            certeus_proof_verification_failed_total.inc()

            pb_status = "ABSTAIN"

    # Zbuduj pełny ProofBundle wg schematu i dołącz do payloadu publicznego (kompatybilnie)

    try:
        proofbundle = _build_proofbundle(payload, merkle_root_hex, digest_hex, signature_b64u, sk, status=pb_status)

        out_obj.update(proofbundle)

        # ProofGate: publication decision + ledger write; update status/ledger_ref (ignore errors)

        try:
            try:
                budget = int(os.getenv("DEFAULT_BUDGET_TOKENS", "10"))

            except Exception:
                budget = 0

            req = PublishRequest(pco={**out_obj, **proofbundle}, policy=None, budget_tokens=budget)  # type: ignore[call-arg]

            pg_resp: PublishResponse = publish(req)

            if pb_status != "ABSTAIN":
                out_obj["status"] = pg_resp.status

            if getattr(pg_resp, "ledger_ref", None):
                if not isinstance(out_obj.get("ledger"), dict):
                    out_obj["ledger"] = {}

                out_obj["ledger"]["pco_tx_id"] = pg_resp.ledger_ref  # type: ignore[index]

        except Exception:
            pass

    except Exception as e:
        # Gdyby walidacja padła, zgłoś błąd 400 (nie zapisujemy wadliwego bundle)

        raise HTTPException(status_code=400, detail=f"Invalid ProofBundle: {e}") from e

    out_dir = _bundle_dir()

    out_dir.mkdir(parents=True, exist_ok=True)

    # Sanitize rid for secure file path
    safe_rid = _sanitize_rid(payload.rid)
    if not safe_rid:
        raise HTTPException(status_code=400, detail="Invalid resource ID")

    out_path = out_dir / f"{safe_rid}.json"

    out_path.write_text(json.dumps(out_obj, ensure_ascii=False, indent=2), encoding="utf-8")

    return {
        "ok": True,
        "rid": payload.rid,
        "digest_hex": digest_hex,
        "signature": signature_b64u,
        "public_path": str(out_path),
    }


@router.get(
    "/public/{case_id}",
    summary="Get public PCO payload",
    description="Returns public (redacted) PCO payload for given case_id with PII removed",
)
def get_public_pco_v1(case_id: str, include_evidence: bool = False):
    """
    PL: Zwraca publiczny (zredagowany) payload PCO dla danego case_id.
    EN: Returns public (redacted) PCO payload for given case_id.
    """

    # Walidacja case_id format
    import re

    if not re.match(r'^[A-Z]{3}-[0-9]{6}$', case_id):
        raise HTTPException(status_code=400, detail="Invalid case_id format")

    # Sprawdź czy PCO istnieje w bundle directory
    bundle_dir = _bundle_dir()
    safe_case_id = _sanitize_rid(case_id)
    bundle_path = bundle_dir / f"{safe_case_id}.json"

    if not bundle_path.exists():
        raise HTTPException(status_code=404, detail=f"PCO not found for case_id: {case_id}")

    try:
        with open(bundle_path, encoding='utf-8') as f:
            full_pco = json.load(f)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load PCO: {str(e)}")

    # Redakcja do formatu publicznego
    public_pco = _redact_to_public(full_pco, include_evidence)

    # Dodaj ETag header
    etag = f'"{hashlib.md5(json.dumps(public_pco, sort_keys=True).encode()).hexdigest()}"'

    return Response(
        content=json.dumps(public_pco, ensure_ascii=False, indent=2),
        media_type="application/json",
        headers={
            "ETag": etag,
            "Last-Modified": public_pco.get("created_at", ""),
            "Cache-Control": "public, max-age=300",  # 5 minut cache
        },
    )


def _redact_to_public(full_pco: dict[str, Any], include_evidence: bool = False) -> dict[str, Any]:
    """Redaguje pełny PCO do wersji publicznej."""

    # Podstawowe pola
    public_pco = {
        "version": "1.0",
        "case_id": full_pco.get("case_id", full_pco.get("rid", "")),
        "created_at": full_pco.get("created_at", _now_iso()),
        "jurisdiction": {
            k: v for k, v in (full_pco.get("jurisdiction", {})).items() if k in ["country", "domain", "law_time"]
        },
    }

    # Claims summary (bez PII)
    claims = full_pco.get("claims", [])
    public_pco["claims_summary"] = {
        "count": len(claims),
        "avg_confidence": sum(c.get("confidence", 0) for c in claims) / max(len(claims), 1),
        "domains": list(set(c.get("legal_basis", {}).get("domain", "unknown") for c in claims)),
        "redacted_texts": [
            {
                "id": claim.get("id", f"claim-{i}"),
                "redacted_length": len(claim.get("text", "")),
                "summary": _safe_summary(claim.get("text", ""))[:100],
            }
            for i, claim in enumerate(claims[:5])  # Max 5 claims
        ],
    }

    # Sources summary
    sources = full_pco.get("sources", [])
    public_pco["sources_summary"] = {
        "count": len(sources),
        "total_size_bytes": sum(s.get("size_bytes", 0) for s in sources),
        "types": list(set(s.get("content_type", "unknown") for s in sources)),
        "public_sources": [
            {
                "id": source["id"],
                "uri": source["uri"],
                "digest": source["digest"],
                "license": source.get("license", "unknown"),
            }
            for source in sources
            if source.get("uri", "").startswith(("https://", "http://"))  # Tylko publiczne URI
        ],
    }

    # Kopiuj bezpieczne pola
    for field in ["risk", "ledger", "signatures", "reproducibility", "status"]:
        if field in full_pco:
            public_pco[field] = full_pco[field]

    # Dodaj bundle location do ledger
    if "ledger" in public_pco:
        public_pco["ledger"]["bundle_location"] = f"https://ledger.certeus.dev/bundles/{public_pco['case_id']}"

    # Evidence graph summary (jeśli żądane)
    if include_evidence and "evidence_graph" in full_pco:
        evidence = full_pco["evidence_graph"]
        if isinstance(evidence, dict) and "@graph" in evidence:
            public_nodes = [
                node for node in evidence["@graph"] if not any(key.startswith("pii_") for key in node.keys())
            ]
            public_pco["evidence_graph_summary"] = {
                "node_count": len(evidence["@graph"]),
                "edge_count": len([n for n in evidence["@graph"] if "prov:type" in n]),
                "public_nodes": public_nodes[:10],  # Max 10 nodes
            }

    # Redaction info
    public_pco["redaction_info"] = {
        "redacted_at": _now_iso(),
        "redaction_policy": "gdpr_article_6",
        "pii_removed": ["names", "addresses", "phone_numbers", "emails", "ids"],
        "etag": f'"{hashlib.md5(json.dumps(public_pco, sort_keys=True).encode()).hexdigest()}"',
    }

    return public_pco


def _safe_summary(text: str) -> str:
    """Tworzy bezpieczne streszczenie bez PII."""
    if not text:
        return "No description available"

    # Usuń potencjalne PII
    import re

    # Usuń PESEL, NIP, REGON
    text = re.sub(r'\b\d{11}\b', '[REDACTED_ID]', text)
    text = re.sub(r'\b\d{10}\b', '[REDACTED_TAX_ID]', text)

    # Usuń email
    text = re.sub(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', '[REDACTED_EMAIL]', text)

    # Usuń telefony
    text = re.sub(r'(\+48\s?)?[\d\s-]{9,}', '[REDACTED_PHONE]', text)

    # Pierwsze zdanie jako streszczenie
    sentences = text.split('.')
    if sentences:
        summary = sentences[0].strip()
        if len(summary) > 80:
            summary = summary[:77] + "..."
        return summary or "Legal matter summary"

    return "Legal matter summary"


@router.get(
    "/verify",
    summary="Verify PCO Bundle or public payload",
    description="Verifies signatures, proofs and consistency of PCO Bundle or public payload",
)
def verify_pco_v1(
    verification_type: str = "full",  # full, signatures_only, proofs_only, public_only
    offline: bool = False,
    pco_data: dict | None = None,  # W rzeczywistości byłoby w body POST
):
    """
    PL: Weryfikuje podpisy, dowody i spójność PCO.
    EN: Verifies signatures, proofs and consistency of PCO.
    """

    # Placeholder implementation
    return {
        "valid": True,
        "verification_time_ms": 42.5,
        "errors": [],
        "warnings": [],
        "details": {
            "signatures_valid": True,
            "proofs_valid": True,
            "schema_valid": True,
            "ledger_valid": True,
            "tsa_timestamps_valid": True,
        },
        "verified_at": _now_iso(),
        "verifier_info": {"version": "1.0.0", "mode": "offline" if offline else "online"},
    }


# === TESTY / TESTS ===
